<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crapcraft v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .menu {
            position: fixed;
            inset: 0;
            background: repeating-linear-pattern;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            background: #222;
        }

        .menu-title {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 0px #3f3f3f;
            margin-bottom: 40px;
        }

        .menu-button {
            background: #8b8b8b;
            border: none;
            padding: 12px 0;
            width: 300px;
            font-size: 16px;
            color: #fff;
            text-shadow: 2px 2px 0px #3f3f3f;
            cursor: pointer;
            margin: 5px 0;
        }

        .menu-button:hover {
            background: #a0a0a0;
        }

        .hud {
            position: fixed;
            pointer-events: none;
            z-index: 10;
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }

        .crosshair::before {
            top: 50%;
            left: 20%;
            width: 60%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 20%;
            height: 60%;
            width: 2px;
            transform: translateX(-50%);
        }

        .toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px;
        }

        .block-slot {
            width: 48px;
            height: 48px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            pointer-events: all;
            background: rgba(139, 139, 139, 0.5);
        }

        .block-slot.active {
            border-color: #fff;
            border-width: 3px;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            font-size: 12px;
            line-height: 1.4;
        }

        .settings {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-size: 12px;
            pointer-events: all;
        }

        .settings label {
            display: block;
            margin: 5px 0;
        }

        .inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #fff;
            padding: 20px;
            display: none;
            pointer-events: all;
            max-height: 80vh;
            overflow-y: auto;
        }

        .inventory.active {
            display: block;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            gap: 5px;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            background: #333;
        }

        .inventory-slot:hover {
            background: #555;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" class="hidden"></canvas>
    
    <div class="menu" id="mainMenu">
        <div class="menu-title">CRAPCRAFT</div>
        <button class="menu-button" id="playBtn">Singleplayer</button>
        <button class="menu-button" id="newBtn">New World</button>
    </div>

    <div class="hud hidden" id="hud">
        <div class="crosshair"></div>
        <div class="debug-info" id="debugInfo"></div>
        <div class="settings">
            <label>FOV: <span id="fovValue">70</span>
                <input type="range" id="fovSlider" min="60" max="110" value="70">
            </label>
        </div>
        <div class="toolbar" id="toolbar"></div>
        <div class="inventory" id="inventory">
            <h2>INVENTORY (Press E to close)</h2>
            <div class="inventory-grid" id="inventoryGrid"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Shaders with block highlighting
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform vec3 uHighlightBlock;
            uniform float uHighlight;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec2 vTexCoord;
            varying float vHighlight;
            
            void main() {
                gl_Position = uProjection * uView * vec4(aPosition, 1.0);
                vColor = aColor;
                vNormal = aNormal;
                vTexCoord = aTexCoord;
                
                vec3 blockPos = floor(aPosition);
                vHighlight = (abs(blockPos.x - uHighlightBlock.x) < 0.5 && 
                             abs(blockPos.y - uHighlightBlock.y) < 0.5 && 
                             abs(blockPos.z - uHighlightBlock.z) < 0.5) ? uHighlight : 0.0;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec2 vTexCoord;
            varying float vHighlight;
            
            uniform vec3 uFogColor;
            uniform float uFogNear;
            uniform float uFogFar;
            
            void main() {
                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                float diffuse = max(dot(normalize(vNormal), lightDir), 0.3);
                vec3 ambient = vec3(0.6, 0.7, 1.0) * 0.4;
                
                // Simple procedural texture
                float pattern = mod(floor(vTexCoord.x * 16.0) + floor(vTexCoord.y * 16.0), 2.0) * 0.1;
                vec3 color = vColor * (0.9 + pattern) * diffuse + ambient * vColor;
                
                // Highlight
                if (vHighlight > 0.5) {
                    color += vec3(0.3, 0.3, 0.3);
                }
                
                // Fog
                float dist = gl_FragCoord.z / gl_FragCoord.w;
                float fogFactor = clamp((uFogFar - dist) / (uFogFar - uFogNear), 0.0, 1.0);
                
                gl_FragColor = vec4(mix(uFogColor, color, fogFactor), 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertexShaderSource));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const aNormal = gl.getAttribLocation(program, 'aNormal');
        const aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
        const uProjection = gl.getUniformLocation(program, 'uProjection');
        const uView = gl.getUniformLocation(program, 'uView');
        const uFogColor = gl.getUniformLocation(program, 'uFogColor');
        const uFogNear = gl.getUniformLocation(program, 'uFogNear');
        const uFogFar = gl.getUniformLocation(program, 'uFogFar');
        const uHighlightBlock = gl.getUniformLocation(program, 'uHighlightBlock');
        const uHighlight = gl.getUniformLocation(program, 'uHighlight');

        // All block types
        const ALL_BLOCKS = {
            GRASS: { color: [0.2, 0.8, 0.2], emoji: 'üü©' },
            DIRT: { color: [0.6, 0.4, 0.2], emoji: 'üü´' },
            STONE: { color: [0.5, 0.5, 0.5], emoji: '‚¨ú' },
            WOOD: { color: [0.6, 0.3, 0.1], emoji: 'üü§' },
            SAND: { color: [0.9, 0.9, 0.6], emoji: 'üü®' },
            COBBLESTONE: { color: [0.4, 0.4, 0.4], emoji: '‚¨õ' },
            PLANKS: { color: [0.7, 0.5, 0.2], emoji: 'üü´' },
            BRICKS: { color: [0.7, 0.3, 0.2], emoji: 'üü•' },
            GLASS: { color: [0.8, 0.9, 1.0], emoji: 'üî∑' },
            LEAVES: { color: [0.1, 0.6, 0.1], emoji: 'üçÉ' },
            SNOW: { color: [0.95, 0.95, 1.0], emoji: '‚ùÑÔ∏è' },
            ICE: { color: [0.7, 0.8, 1.0], emoji: 'üßä' },
            OBSIDIAN: { color: [0.1, 0.0, 0.2], emoji: 'üü™' },
            GOLD: { color: [1.0, 0.84, 0.0], emoji: 'üü®' },
            DIAMOND: { color: [0.3, 0.8, 0.9], emoji: 'üíé' }
        };

        const blockNames = Object.keys(ALL_BLOCKS);
        let hotbar = ['GRASS', 'DIRT', 'STONE', 'WOOD', 'SAND', 'COBBLESTONE', 'PLANKS', 'BRICKS', 'GLASS'];
        let selectedSlot = 0;
        let fov = 70;

        // Perlin noise (simplified)
        class Noise {
            constructor() {
                this.p = [];
                for (let i = 0; i < 256; i++) this.p[i] = Math.floor(Math.random() * 256);
                this.p = [...this.p, ...this.p];
            }
            
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.p[X] + Y;
                const b = this.p[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.p[a] / 255, this.p[b] / 255),
                    this.lerp(u, this.p[a + 1] / 255, this.p[b + 1] / 255)
                );
            }
        }

        const noise = new Noise();
        const CHUNK_SIZE = 16;
        const chunks = new Map();
        const player = { pos: [0, 20, 0], vel: [0, 2, 0], yaw: 0, pitch: 0, flying: false, onGround: false };
        const keys = {};
        let mouseLocked = false;
        let gameStarted = false;
        let meshDirty = true;
        let cachedMesh = null;
        let highlightedBlock = null;

        function chunkKey(cx, cz) { return `${cx},${cz}`; }
        function blockKey(x, y, z) { return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; }
        function getChunkCoords(x, z) { return [Math.floor(x / CHUNK_SIZE), Math.floor(z / CHUNK_SIZE)]; }

        function generateChunk(cx, cz) {
            const chunk = new Map();
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const wx = cx * CHUNK_SIZE + x;
                    const wz = cz * CHUNK_SIZE + z;
                    let h = noise.noise(wx * 0.03, wz * 0.03) * 8 + noise.noise(wx * 0.06, wz * 0.06) * 3;
                    const finalH = Math.floor(h + 12);
                    for (let y = 0; y < finalH; y++) {
                        const type = y === finalH - 1 ? 'GRASS' : (y > finalH - 4 ? 'DIRT' : 'STONE');
                        chunk.set(blockKey(wx, y, wz), type);
                    }
                }
            }
            chunks.set(chunkKey(cx, cz), chunk);
        }

        function getBlock(x, y, z) {
            const [cx, cz] = getChunkCoords(x, z);
            const chunk = chunks.get(chunkKey(cx, cz));
            return chunk ? chunk.get(blockKey(x, y, z)) : null;
        }

        function setBlock(x, y, z, type) {
            const [cx, cz] = getChunkCoords(x, z);
            let chunk = chunks.get(chunkKey(cx, cz));
            if (!chunk) {
                generateChunk(cx, cz);
                chunk = chunks.get(chunkKey(cx, cz));
            }
            if (type) chunk.set(blockKey(x, y, z), type);
            else chunk.delete(blockKey(x, y, z));
            meshDirty = true;
        }

        function loadChunks() {
            const [cx, cz] = getChunkCoords(player.pos[0], player.pos[2]);
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    const key = chunkKey(cx + dx, cz + dz);
                    if (!chunks.has(key)) {
                        generateChunk(cx + dx, cz + dz);
                        meshDirty = true;
                    }
                }
            }
        }

        function createCube(x, y, z, type) {
            const c = ALL_BLOCKS[type].color;
            const verts = [];
            const faces = [
                {p:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], n:[0,0,1], c:[0,0,1]},
                {p:[[1,0,0],[0,0,0],[0,1,0],[1,1,0]], n:[0,0,-1], c:[0,0,-1]},
                {p:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], n:[0,1,0], c:[0,1,0]},
                {p:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], n:[0,-1,0], c:[0,-1,0]},
                {p:[[1,0,1],[1,0,0],[1,1,0],[1,1,1]], n:[1,0,0], c:[1,0,0]},
                {p:[[0,0,0],[0,0,1],[0,1,1],[0,1,0]], n:[-1,0,0], c:[-1,0,0]}
            ];
            
            for (const f of faces) {
                if (getBlock(x+f.c[0], y+f.c[1], z+f.c[2])) continue;
                const [p0,p1,p2,p3] = f.p;
                verts.push(
                    x+p0[0],y+p0[1],z+p0[2], ...c, ...f.n, 0, 0,
                    x+p1[0],y+p1[1],z+p1[2], ...c, ...f.n, 1, 0,
                    x+p2[0],y+p2[1],z+p2[2], ...c, ...f.n, 1, 1,
                    x+p0[0],y+p0[1],z+p0[2], ...c, ...f.n, 0, 0,
                    x+p2[0],y+p2[1],z+p2[2], ...c, ...f.n, 1, 1,
                    x+p3[0],y+p3[1],z+p3[2], ...c, ...f.n, 0, 1
                );
            }
            return verts;
        }

        function buildMesh() {
            if (!meshDirty && cachedMesh) return cachedMesh;
            const verts = [];
            const [cx, cz] = getChunkCoords(player.pos[0], player.pos[2]);
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    const chunk = chunks.get(chunkKey(cx+dx, cz+dz));
                    if (!chunk) continue;
                    for (const [key, type] of chunk) {
                        const [x,y,z] = key.split(',').map(Number);
                        verts.push(...createCube(x, y, z, type));
                    }
                }
            }
            cachedMesh = new Float32Array(verts);
            meshDirty = false;
            return cachedMesh;
        }

        function raycast() {
            const fwd = [
                Math.sin(player.yaw) * Math.cos(player.pitch),
                Math.sin(player.pitch),
                -Math.cos(player.yaw) * Math.cos(player.pitch)
            ];
            let pos = [...player.pos];
            for (let d = 0; d < 10; d += 0.1) {
                pos[0] += fwd[0] * 0.1;
                pos[1] += fwd[1] * 0.1;
                pos[2] += fwd[2] * 0.1;
                const x = Math.floor(pos[0]), y = Math.floor(pos[1]), z = Math.floor(pos[2]);
                if (getBlock(x, y, z)) {
                    const prev = [pos[0]-fwd[0]*0.1, pos[1]-fwd[1]*0.1, pos[2]-fwd[2]*0.1];
                    return { hit: [x,y,z], prev: [Math.floor(prev[0]), Math.floor(prev[1]), Math.floor(prev[2])] };
                }
            }
            return null;
        }

        function checkCollision(x, y, z) {
            for (let dx = -0.3; dx <= 0.3; dx += 0.3) {
                for (let dy = 0; dy < 1.8; dy += 0.9) {
                    for (let dz = -0.3; dz <= 0.3; dz += 0.3) {
                        if (getBlock(Math.floor(x+dx), Math.floor(y+dy), Math.floor(z+dz))) return true;
                    }
                }
            }
            return false;
        }

        // Matrix math
        function perspective(fov, aspect, near, far) {
            const f = 1 / Math.tan(fov / 2);
            return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)/(near-far),-1, 0,0,2*far*near/(near-far),0];
        }

        function lookAt(eye, target, up) {
            const z = normalize([eye[0]-target[0], eye[1]-target[1], eye[2]-target[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return [x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1];
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return len > 0 ? [v[0]/len, v[1]/len, v[2]/len] : [0,0,0];
        }

        function cross(a, b) {
            return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        const buffer = gl.createBuffer();

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            const verts = buildMesh();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

            const stride = 11 * 4;
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, stride, 12);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, stride, 24);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, stride, 36);
            gl.enableVertexAttribArray(aTexCoord);

            const proj = perspective(fov * Math.PI / 180, canvas.width / canvas.height, 1, 1000);
            gl.uniformMatrix4fv(uProjection, false, proj);

            const fwd = [Math.sin(player.yaw)*Math.cos(player.pitch), Math.sin(player.pitch), -Math.cos(player.yaw)*Math.cos(player.pitch)];
            const view = lookAt(player.pos, [player.pos[0]+fwd[0], player.pos[1]+fwd[1], player.pos[2]+fwd[2]], [0,1,0]);
            gl.uniformMatrix4fv(uView, false, view);

            gl.uniform3f(uFogColor, 0.53, 0.81, 0.92);
            gl.uniform1f(uFogNear, 20);
            gl.uniform1f(uFogFar, 60);
            
            if (highlightedBlock) {
                gl.uniform3fv(uHighlightBlock, highlightedBlock);
                gl.uniform1f(uHighlight, 1.0);
            } else {
                gl.uniform1f(uHighlight, 0.0);
            }

            gl.drawArrays(gl.TRIANGLES, 0, verts.length / 11);
        }

        function updatePhysics(dt) {
            if (!gameStarted) return;
            const speed = player.flying ? 10 : 4.3;
            const fwd = [Math.sin(player.yaw), 0, -Math.cos(player.yaw)];
            const right = [Math.cos(player.yaw), 0, Math.sin(player.yaw)];
            let move = [0, 0, 0];

            if (keys.KeyW) { move[0] += fwd[0]; move[2] += fwd[2]; }
            if (keys.KeyS) { move[0] -= fwd[0]; move[2] -= fwd[2]; }
            if (keys.KeyA) { move[0] -= right[0]; move[2] -= right[2]; }
            if (keys.KeyD) { move[0] += right[0]; move[2] += right[2]; }

            const len = Math.sqrt(move[0]**2 + move[2]**2);
            if (len > 0) {
                move[0] = move[0]/len * speed * dt;
                move[2] = move[2]/len * speed * dt;
            }

            if (!checkCollision(player.pos[0]+move[0], player.pos[1], player.pos[2])) player.pos[0] += move[0];
            if (!checkCollision(player.pos[0], player.pos[1], player.pos[2]+move[2])) player.pos[2] += move[2];

            if (player.flying) {
                if (keys.Space) player.pos[1] += speed * dt;
                if (keys.ShiftLeft) player.pos[1] -= speed * dt;
                player.vel[1] = 0;
                player.onGround = false;
            } else {
                player.vel[1] -= 25 * dt;
                if (keys.Space && player.onGround) {
                    player.vel[1] = 8.5;
                    player.onGround = false;
                }
                if (!checkCollision(player.pos[0], player.pos[1]+player.vel[1]*dt, player.pos[2])) {
                    player.pos[1] += player.vel[1] * dt;
                    player.onGround = false;
                } else {
                    if (player.vel[1] < 0) player.onGround = true;
                    player.vel[1] = 0;
                }
            }
        }

        // UI
        function setupUI() {
            const toolbar = document.getElementById('toolbar');
            hotbar.forEach((type, i) => {
                const slot = document.createElement('div');
                slot.className = 'block-slot' + (i === 0 ? ' active' : '');
                slot.innerHTML = ALL_BLOCKS[type].emoji;
                slot.onclick = () => { selectedSlot = i; updateToolbar(); };
                toolbar.appendChild(slot);
            });

            const grid = document.getElementById('inventoryGrid');
            blockNames.forEach(name => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.innerHTML = ALL_BLOCKS[name].emoji;
                slot.onclick = () => {
                    hotbar[selectedSlot] = name;
                    updateToolbar();
                    document.getElementById('inventory').classList.remove('active');
                };
                grid.appendChild(slot);
            });
        }

        function updateToolbar() {
            const slots = document.querySelectorAll('.block-slot');
            slots.forEach((slot, i) => {
                slot.classList.toggle('active', i === selectedSlot);
                slot.innerHTML = ALL_BLOCKS[hotbar[i]].emoji;
            });
        }

        // Events
        document.getElementById('playBtn').onclick = () => {
            loadChunks();
            document.getElementById('mainMenu').classList.add('hidden');
            canvas.classList.remove('hidden');
            document.getElementById('hud').classList.remove('hidden');
            gameStarted = true;
            canvas.requestPointerLock();
        };

        document.getElementById('newBtn').onclick = () => {
            chunks.clear();
            player.pos = [0, 20, 0];
            player.vel = [0, 0, 0];
            meshDirty = true;
            document.getElementById('playBtn').click();
        };

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
        });

        canvas.onclick = () => {
            if (gameStarted && !mouseLocked) canvas.requestPointerLock();
        };

        window.addEventListener('keydown', e => {
            if (!gameStarted) return;
            keys[e.code] = true;

            if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                const num = parseInt(e.code.slice(-1)) - 1;
                if (num < hotbar.length) {
                    selectedSlot = num;
                    updateToolbar();
                }
            }

            if (e.code === 'KeyF') {
                player.flying = !player.flying;
                player.vel[1] = 0;
            }

            if (e.code === 'KeyE') {
                document.getElementById('inventory').classList.toggle('active');
            }

            if (e.code === 'Escape') {
                if (document.getElementById('inventory').classList.contains('active')) {
                    document.getElementById('inventory').classList.remove('active');
                } else {
                    document.exitPointerLock();
                    document.getElementById('mainMenu').classList.remove('hidden');
                    canvas.classList.add('hidden');
                    document.getElementById('hud').classList.add('hidden');
                    gameStarted = false;
                }
            }
        });

        window.addEventListener('keyup', e => { keys[e.code] = false; });

        window.addEventListener('mousemove', e => {
            if (!mouseLocked || !gameStarted) return;
            player.yaw += e.movementX * 0.002;  // FIXED: Changed from -= to +=
            player.pitch -= e.movementY * 0.002;
            player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
        });

        window.addEventListener('mousedown', e => {
            if (!mouseLocked || !gameStarted) return;
            const hit = raycast();
            if (hit) {
                if (e.button === 0) {
                    setBlock(...hit.hit, null);  // Optimized: setBlock already marks mesh dirty
                } else if (e.button === 2) {
                    if (!checkCollision(hit.prev[0]+0.5, hit.prev[1], hit.prev[2]+0.5)) {
                        setBlock(...hit.prev, hotbar[selectedSlot]);
                    }
                }
            }
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        document.getElementById('fovSlider').oninput = e => {
            fov = parseInt(e.target.value);
            document.getElementById('fovValue').textContent = fov;
        };

        let lastTime = 0, lastChunkCheck = 0;

        function gameLoop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            updatePhysics(dt);

            if (time - lastChunkCheck > 1000) {
                loadChunks();
                lastChunkCheck = time;
            }

            // Update highlight
            const hit = raycast();
            highlightedBlock = hit ? hit.hit : null;

            render();

            if (gameStarted) {
                const [cx, cz] = getChunkCoords(player.pos[0], player.pos[2]);
                document.getElementById('debugInfo').innerHTML = `
                    X: ${player.pos[0].toFixed(1)} Y: ${player.pos[1].toFixed(1)} Z: ${player.pos[2].toFixed(1)}<br>
                    Chunk: ${cx}, ${cz}<br>
                    ${player.flying ? 'Flying' : (player.onGround ? 'Ground' : 'Air')}<br>
                    Mouse: ${mouseLocked ? 'üîí' : '‚ùå Click'}
                `;
            }

            requestAnimationFrame(gameLoop);
        }

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.53, 0.81, 0.92, 1.0);
        setupUI();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>